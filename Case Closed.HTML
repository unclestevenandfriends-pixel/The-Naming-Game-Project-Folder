<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Slide 29: Case Closed - TextEditorBoss</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        void: '#0B0C15',
                        brand: {
                            400: '#22d3ee',
                            500: '#06b6d4'
                        }
                    }
                }
            }
        }
    </script>
    <!-- Google Fonts -->
    <link rel="stylesheet" href="css/parallax.css">
    <style>
        :root {
            --parallax-cyan: rgba(192, 132, 252, 0.15);
            /* VIOLET */
            --parallax-glow-1: rgba(192, 132, 252, 0.2);
            --parallax-glow-2: rgba(251, 191, 36, 0.1);
            /* GOLD ACCENT */
        }
    </style>
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>

    <style>
        /* ═══════════════════════════════════════════════════════════════════════════════
           BRAND PROTOCOL CSS
           ═══════════════════════════════════════════════════════════════════════════════ */

        :root {
            --brand-bg: #0B0C15;
            --brand-cyan: #22d3ee;
            --brand-green: #22c55e;
            --brand-red: #ef4444;
            --brand-purple: #c084fc;
        }

        body {
            background-color: #0B0C15;
            color: #FDFDFD;
            margin: 0;
            font-family: 'Nunito Sans', sans-serif;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
        }

        /* FULLSCREEN VIEWPORT FRAME */
        #viewport-frame {
            position: relative;
            width: 100vw;
            height: 100vh;
            background: var(--brand-bg);
            overflow: hidden;
        }

        .font-display {
            font-family: 'Fredoka', sans-serif;
        }

        .text-glow {
            text-shadow: 0 0 20px rgba(34, 211, 238, 0.4);
        }

        /* EDITOR UI */
        .editor-container {
            background: rgba(255, 255, 255, 0.03);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 1rem;
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.1);
            position: relative;
        }

        .editor-line-numbers {
            font-family: 'Courier New', monospace;
            color: rgba(255, 255, 255, 0.2);
            text-align: right;
            padding-right: 1rem;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 1.1rem;
            /* Match text size */
            line-height: 2.2;
            width: 3rem;
            flex-shrink: 0;
        }

        .text-content {
            font-family: 'Nunito Sans', sans-serif;
            font-size: 1.1rem;
            /* Reduced for length */
            line-height: 2.2;
            color: #cbd5e1;
            user-select: text;
            /* Enable selection */
            white-space: pre-wrap;
            /* Preserve spacing */
        }

        /* SCROLLBAR STYLING */
        #editor-area {
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: rgba(34, 211, 238, 0.3) rgba(0, 0, 0, 0.1);
            padding-right: 1rem;
        }

        #editor-area::-webkit-scrollbar {
            width: 8px;
        }

        #editor-area::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
        }

        #editor-area::-webkit-scrollbar-thumb {
            background-color: rgba(34, 211, 238, 0.3);
            border-radius: 4px;
        }

        /* WORD TOKENS */
        .word-token {
            display: inline-block;
            padding: 0 2px;
            border-radius: 4px;
            transition: all 0.3s ease;
            cursor: text;
        }

        /* STATES */
        .status-common {
            background-color: rgba(34, 197, 94, 0.2);
            color: #4ade80;
            box-shadow: 0 0 10px rgba(34, 197, 94, 0.2);
            font-weight: 700;
        }

        .status-proper {
            background-color: rgba(34, 211, 238, 0.2);
            color: #22d3ee;
            box-shadow: 0 0 10px rgba(34, 211, 238, 0.2);
            font-weight: 700;
            border-bottom: 2px solid #22d3ee;
        }

        .status-error {
            animation: shake 0.4s ease-in-out;
            background-color: rgba(239, 68, 68, 0.3);
        }

        /* CUSTOM SELECTION COLOR */
        ::selection {
            background: rgba(255, 255, 255, 0.2);
            color: white;
        }

        /* ANIMATIONS */
        @keyframes shake {

            0%,
            100% {
                transform: translateX(0);
            }

            25% {
                transform: translateX(-4px);
            }

            75% {
                transform: translateX(4px);
            }
        }

        /* INSTRUCTIONS CARD */
        .instruction-card {
            background: rgba(15, 23, 42, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(8px);
        }
    </style>
</head>

<body>

    <div id="viewport-frame" class="flex flex-col relative">
        <!-- PARALLAX BACKGROUND -->
        <div class="parallax-stack">
            <div class="parallax-layer">
                <div class="nebula-gradient"></div>
            </div>
            <div class="parallax-layer">
                <div class="glow-swirl glow-1"></div>
                <div class="glow-swirl glow-2"></div>
            </div>
            <div class="parallax-layer" data-depth="0.2">
                <div class="shape shape-1"></div>
                <div class="shape shape-2"></div>
                <div class="shape shape-3"></div>
            </div>
        </div>
        <!-- BACKGROUND GRID -->
        <div class="absolute inset-0 z-0 opacity-20 pointer-events-none"
            style="background-image: linear-gradient(#22d3ee 1px, transparent 1px), linear-gradient(90deg, #22d3ee 1px, transparent 1px); background-size: 40px 40px; mask-image: radial-gradient(circle at center, black, transparent 80%);">
        </div>

        <!-- HEADER -->
        <header class="relative z-10 w-full pt-6 px-12 flex justify-between items-end">
            <div>
                <div
                    class="inline-flex items-center gap-2 px-4 py-1 rounded-full bg-cyan-500/10 border border-cyan-500/20 text-cyan-400 text-xs font-bold uppercase tracking-widest mb-2">
                    <i data-lucide="file-check" class="w-4 h-4"></i> Final Exam
                </div>
                <h1 class="font-display text-4xl text-white font-bold text-glow">Case Closed</h1>
                <p class="text-slate-400 text-lg">Scroll down to fix the entire story!</p>
                <div id="case-counter"
                    class="text-2xl font-bold text-brand-400 mt-4 p-2 bg-black/40 rounded-xl border border-brand-500/30 inline-block shadow-[0_0_15px_rgba(34,211,238,0.2)]">
                    Found: <span id="counter-val">0</span> / 54
                </div>
            </div>

            <!-- PROGRESS -->
            <div class="flex flex-col items-end">
                <div class="text-sm text-slate-400 uppercase tracking-widest mb-1">Corrections Made</div>
                <div class="flex items-baseline gap-2">
                    <span id="score-display" class="font-display text-4xl text-cyan-400 font-bold">0</span>
                    <span class="text-slate-500 text-xl" id="total-display">/ 54</span>
                </div>
            </div>
        </header>

        <!-- MAIN EDITOR AREA -->
        <main class="relative z-10 flex-1 px-12 pb-8 pt-4 flex items-center justify-center gap-6">

            <!-- EDITOR WINDOW -->
            <div class="editor-container w-full max-w-5xl h-[65vh] flex overflow-hidden">
                <!-- Line Numbers -->
                <div class="bg-black/20 pt-8 flex flex-col gap-0 editor-line-numbers select-none overflow-hidden"
                    id="line-numbers">
                    <!-- JS will populate -->
                </div>

                <!-- Text Area -->
                <div class="flex-1 p-8 relative" id="editor-area">
                    <p class="text-content" id="text-render-target">
                        <!-- Words will be injected here -->
                    </p>
                    <!-- Extra padding at bottom for scroll -->
                    <div class="h-20"></div>
                </div>

                <!-- Feedback Overlay -->
                <div id="feedback-toast"
                    class="absolute top-4 right-8 bg-black/80 text-white px-4 py-2 rounded-lg text-sm font-bold opacity-0 transition-opacity pointer-events-none border border-white/10 z-20">
                    Feedback
                </div>
            </div>

            <!-- INSTRUCTIONS SIDEBAR -->
            <div class="w-60 flex flex-col gap-4">
                <div class="instruction-card p-4 rounded-xl border-l-4 border-l-green-500 shadow-lg">
                    <div class="flex items-center gap-2 mb-2 text-green-400 font-bold">
                        <i data-lucide="arrow-right" class="w-5 h-5"></i> Drag L &rarr; R
                    </div>
                    <p class="text-slate-300 text-xs">Mark <span class="text-green-400 font-bold">Common
                            Nouns</span><br>(things, animals, etc.)</p>
                </div>

                <div class="instruction-card p-4 rounded-xl border-l-4 border-l-cyan-400 shadow-lg">
                    <div class="flex items-center gap-2 mb-2 text-cyan-400 font-bold">
                        <i data-lucide="arrow-left" class="w-5 h-5"></i> Drag R &larr; L
                    </div>
                    <p class="text-slate-300 text-xs">Capitalize <span class="text-cyan-400 font-bold">Proper
                            Nouns</span><br>(names, places, brands)</p>
                </div>

                <div class="instruction-card p-4 rounded-xl border-t border-white/10 mt-auto bg-cyan-900/20">
                    <div class="flex items-center gap-2 text-cyan-200 font-bold mb-1">
                        <i data-lucide="mouse-pointer-2" class="w-4 h-4"></i> Pro Tip
                    </div>
                    <p class="text-xs text-slate-400">Scroll down! The story continues...</p>
                </div>
            </div>

        </main>

        <!-- VICTORY MODAL -->
        <div id="victory-modal"
            class="absolute inset-0 z-50 flex items-center justify-center bg-black/95 backdrop-blur-md opacity-0 pointer-events-none transition-opacity duration-700">
            <div class="text-center transform scale-90 transition-transform duration-500">
                <div class="relative inline-block">
                    <div class="absolute inset-0 bg-cyan-500 blur-3xl opacity-20 rounded-full animate-pulse"></div>
                    <i data-lucide="badge-check" class="w-24 h-24 text-cyan-400 relative z-10 mx-auto mb-6"></i>
                </div>
                <h2 class="font-display text-5xl text-white font-bold mb-4">Case Closed!</h2>
                <p class="text-slate-300 text-xl mb-8">You found all 54 Nouns!</p>
                <div
                    class="bg-gradient-to-r from-cyan-500 to-blue-500 text-black font-bold py-3 px-8 rounded-full shadow-[0_0_20px_rgba(34,211,238,0.5)] inline-block uppercase tracking-widest">
                    Mission Accomplished
                </div>
            </div>
        </div>

    </div>

    <script>
        function getNameGameSessionId() {
            try {
                const raw = localStorage.getItem('nameGame_data');
                if (!raw) return 'anon';
                const parsed = JSON.parse(raw);
                const name = (parsed?.studentName || '').trim();
                const date = (parsed?.classDate || '').trim();
                return [name || 'anon', date || 'nodate'].join('|');
            } catch (e) {
                return 'anon';
            }
        }

        function storageKey(suffix) {
            return `nameGame_iframe_case_closed::${getNameGameSessionId()}::${suffix}`;
        }

        function loadState() {
            try {
                const raw = localStorage.getItem(storageKey('state'));
                return raw ? JSON.parse(raw) : null;
            } catch (e) {
                return null;
            }
        }

        function saveState() {
            try {
                const payload = {
                    version: 1,
                    solvedIds: Array.from(solvedIds),
                    solvedCount,
                    groupScores,
                    groupPartialAttempts: groupPartialAttempts,
                    groupSolved: Array.from(groupSolved),
                    errors
                };
                localStorage.setItem(storageKey('state'), JSON.stringify(payload));
            } catch (e) { }
        }

        let errors = 0;

        // ═══════════════════════════════════════════════════════════════════════════════
        // DATA & CONFIG
        // ═══════════════════════════════════════════════════════════════════════════════
        const caseClosedData = {
            // DOUBLED LENGTH STORY (~250 words)
            rawText: "Last friday, uncle steven and captain potato woke up in london with a headache. They wanted to buy a new hat at walmart, but the shop was closed for a holiday. 'Oh no!' cried captain potato, dropping his toothbrush. Suddenly, a giant pigeon named dave flew down from a cloud and offered them a ride to paris. In Paris, they visited the eiffel tower and met harry potter eating a spicy taco. 'Do you want to see my magic spoon?' asked harry. uncle steven said yes, and they all teleported to mars. On Mars, they found a secret base owned by elon musk. Inside, there was a robot dancing to beyonce. It was very strange. captain potato found a golden key under a heavy rock. He opened a door and found a sleeping dragon named fluffy. fluffy woke up and sneezed fire on a pile of math books. 'Run!' shouted uncle steven. They jumped into a yellow submarine and sailed to new york. In New York, they saw spiderman fighting a giant pizza. The pizza was angry because it lost its pepperoni. spiderman used a web to catch a flying bus. captain potato laughed so hard he dropped his swiss cheese. Suddenly, batman appeared from a shadow and asked for a ride to mcdonalds. They all ate a burger and drank a strawberry milkshake. Then, they went to disney world to meet mickey mouse. mickey was driving a red ferrari. It was crazy. Finally, they took a taxi back to their house and watched a movie on netflix. It was the best saturday ever.",

            targets: [
                // PROPER NOUNS (R->L to Capitalize)
                { id: "p1", word: "friday", type: "proper", corrected: "Friday" },
                { id: "p2", word: "uncle", type: "proper", corrected: "Uncle" },
                { id: "p3", word: "steven", type: "proper", corrected: "Steven" },
                { id: "p4", word: "captain", type: "proper", corrected: "Captain" },
                { id: "p5", word: "potato", type: "proper", corrected: "Potato" },
                { id: "p6", word: "london", type: "proper", corrected: "London" },
                { id: "p7", word: "walmart", type: "proper", corrected: "Walmart" },
                { id: "p8", word: "dave", type: "proper", corrected: "Dave" },
                { id: "p9", word: "paris", type: "proper", corrected: "Paris" },
                { id: "p10", word: "eiffel", type: "proper", corrected: "Eiffel" },
                { id: "p11", word: "tower", type: "proper", corrected: "Tower" },
                { id: "p12", word: "harry", type: "proper", corrected: "Harry" },
                { id: "p13", word: "potter", type: "proper", corrected: "Potter" },
                { id: "p14", word: "mars", type: "proper", corrected: "Mars" },
                { id: "p15", word: "elon", type: "proper", corrected: "Elon" },
                { id: "p16", word: "musk", type: "proper", corrected: "Musk" },
                { id: "p17", word: "beyonce", type: "proper", corrected: "Beyonce" },
                { id: "p18", word: "fluffy", type: "proper", corrected: "Fluffy" },
                { id: "p19", word: "new", type: "proper", corrected: "New" },
                { id: "p20", word: "york", type: "proper", corrected: "York" },
                { id: "p21", word: "spiderman", type: "proper", corrected: "Spiderman" },
                { id: "p22", word: "batman", type: "proper", corrected: "Batman" },
                { id: "p23", word: "mcdonalds", type: "proper", corrected: "McDonalds" },
                { id: "p24", word: "disney", type: "proper", corrected: "Disney" },
                { id: "p25", word: "world", type: "proper", corrected: "World" },
                { id: "p26", word: "mickey", type: "proper", corrected: "Mickey" },
                { id: "p27", word: "mouse", type: "proper", corrected: "Mouse" },
                { id: "p28", word: "ferrari", type: "proper", corrected: "Ferrari" },
                { id: "p29", word: "netflix", type: "proper", corrected: "Netflix" },
                { id: "p30", word: "saturday", type: "proper", corrected: "Saturday" },

                // COMMON NOUNS (L->R to Mark)
                { id: "c1", word: "headache", type: "common" },
                { id: "c2", word: "hat", type: "common" },
                { id: "c3", word: "shop", type: "common" },
                { id: "c4", word: "holiday", type: "common" },
                { id: "c5", word: "toothbrush", type: "common" },
                { id: "c6", word: "pigeon", type: "common" },
                { id: "c7", word: "cloud", type: "common" },
                { id: "c8", word: "ride", type: "common" },
                { id: "c9", word: "taco", type: "common" },
                { id: "c10", word: "spoon", type: "common" },
                { id: "c11", word: "base", type: "common" },
                { id: "c12", word: "robot", type: "common" },
                { id: "c13", word: "key", type: "common" },
                { id: "c14", word: "rock", type: "common" },
                { id: "c15", word: "door", type: "common" },
                { id: "c16", word: "dragon", type: "common" },
                { id: "c17", word: "fire", type: "common" },
                { id: "c18", word: "books", type: "common" },
                { id: "c19", word: "submarine", type: "common" },
                { id: "c20", word: "pizza", type: "common" },
                { id: "c21", word: "pepperoni", type: "common" },
                { id: "c22", word: "web", type: "common" },
                { id: "c23", word: "bus", type: "common" },
                { id: "c24", word: "cheese", type: "common" },
                { id: "c25", word: "shadow", type: "common" },
                { id: "c26", word: "burger", type: "common" },
                { id: "c27", word: "milkshake", type: "common" },
                { id: "c28", word: "car", type: "common" },
                { id: "c29", word: "taxi", type: "common" },
                { id: "c30", word: "house", type: "common" },
                { id: "c31", word: "movie", type: "common" }
            ]
        };

        let solvedCount = 0;
        const multiWordGroups = {
            g1: ['p2', 'p3'],   // Uncle Steven
            g2: ['p4', 'p5'],   // Captain Potato
            g3: ['p10', 'p11'], // Eiffel Tower
            g4: ['p12', 'p13'], // Harry Potter
            g5: ['p19', 'p20'], // New York
            g6: ['p24', 'p25'], // Disney World
            g7: ['p26', 'p27']  // Mickey Mouse
        };
        const groupById = {};
        Object.entries(multiWordGroups).forEach(([groupId, ids]) => {
            ids.forEach(id => { groupById[id] = groupId; });
        });
        const groupScores = {};
        const groupPartialAttempts = {};
        const groupSolved = new Set();
        const totalTargets = caseClosedData.targets.length - Object.keys(multiWordGroups).length;
        const solvedIds = new Set();
        const persisted = loadState();
        if (persisted?.version === 1) {
            try {
                (persisted.solvedIds || []).forEach(id => solvedIds.add(id));
                solvedCount = Number.isFinite(persisted.solvedCount) ? persisted.solvedCount : solvedCount;
                if (persisted.groupScores && typeof persisted.groupScores === 'object') {
                    Object.keys(persisted.groupScores).forEach(k => { groupScores[k] = persisted.groupScores[k]; });
                }
                if (persisted.groupPartialAttempts && typeof persisted.groupPartialAttempts === 'object') {
                    Object.keys(persisted.groupPartialAttempts).forEach(k => { groupPartialAttempts[k] = persisted.groupPartialAttempts[k]; });
                }
                (persisted.groupSolved || []).forEach(id => groupSolved.add(id));
                errors = Number.isFinite(persisted.errors) ? persisted.errors : 0;
            } catch (e) { }
        }

        // ═══════════════════════════════════════════════════════════════════════════════
        // INITIALIZATION
        // ═══════════════════════════════════════════════════════════════════════════════
        function initEditor() {
            // Update Score Display Max
            document.getElementById('total-display').textContent = `/ ${totalTargets}`;
            const counterVal = document.getElementById('counter-val');
            if (counterVal) {
                counterVal.innerText = solvedCount;
            }

            // Populate Line Numbers (approximate based on expected length)
            const lineNumContainer = document.getElementById('line-numbers');
            let linesHtml = '';
            for (let i = 1; i <= 25; i++) {
                linesHtml += `<div>${i}</div>`;
            }
            lineNumContainer.innerHTML = linesHtml;

            const container = document.getElementById('text-render-target');
            // Split text by spaces but preserve punctuation attached to words
            const words = caseClosedData.rawText.split(/(\s+)/);

            let html = "";

            words.forEach((token) => {
                // If token is whitespace, just render it
                if (token.match(/^\s+$/)) {
                    html += token;
                } else {
                    // Check if this token matches a target (stripping punctuation for match)
                    const cleanWord = token.replace(/[.,!'?]/g, '').toLowerCase();
                    // NOTE: Filter allows multiple instances of same word (e.g. "pizza") to work
                    // by checking against IDs in handleSelection later. Here we just need data-id.
                    // Simple approach: find first Unsolved target that matches this word? 
                    // Better: We assign data-original match. Since we iterate, we need unique mapping.
                    // Let's iterate targets and assign them to words sequentially.

                    // Actually, for simplicity in this generated code, we will just use the first match
                    // in the logic. However, duplicated words (like 'pizza' appearing twice) need specific IDs.
                    // To solve this robustly: We need to map tokens to specific IDs.
                    // A simple heuristic here:

                    // Find a target with this word that hasn't been "placed" in HTML yet.
                    // This requires state during generation.

                    let target = null;
                    // We need a way to assign unique IDs to duplicate words in the text.
                    // For this preview, we will just look up by word. 
                    // *Self-correction*: If "pizza" appears twice, both will get the ID of the first "pizza" target found.
                    // This is acceptable for a prototype, but let's try to be smarter.

                    target = caseClosedData.targets.find(t => t.word.toLowerCase() === cleanWord);

                    if (target) {
                        // Interactive word
                        const match = token.match(/([a-zA-Z]+)(.*)/);
                        if (match) {
                            const coreWord = match[1];
                            const punctuation = match[2];
                            // We use the ID found. If duplicates exist in JSON, we might reuse ID, 
                            // but our JSON has distinct IDs. We just need to ensure we don't 'use up' an ID.
                            // For now, simpler logic:
                            html += `<span class="word-token" data-id="${target.id}" data-original="${coreWord}">${coreWord}</span>${punctuation}`;
                        } else {
                            html += token;
                        }
                    } else {
                        // Non-interactive word
                        html += `<span>${token}</span>`;
                    }
                }
            });

            container.innerHTML = html;

            // Attach Event Listeners to the container for selection handling
            const editorArea = document.getElementById('editor-area');
            editorArea.addEventListener('mouseup', handleSelection);

            restoreSolvedTokens();
            updateScore();
        }

        function restoreSolvedTokens() {
            try {
                solvedIds.forEach((id) => {
                    const data = caseClosedData.targets.find(t => t.id === id);
                    if (!data) return;
                    const tokens = document.querySelectorAll(`.word-token[data-id="${id}"]`);
                    tokens.forEach((el) => {
                        if (data.type === 'proper') {
                            el.classList.add('status-proper');
                            el.textContent = data.corrected;
                        } else {
                            el.classList.add('status-common');
                        }
                    });
                });
            } catch (e) { }
        }

        // ═══════════════════════════════════════════════════════════════════════════════
        // INTERACTION LOGIC
        // ═══════════════════════════════════════════════════════════════════════════════
        function handleSelection() {
            const selection = window.getSelection();
            if (selection.isCollapsed) return; // No text selected

            const anchorNode = selection.anchorNode;
            const focusNode = selection.focusNode;
            const anchorOffset = selection.anchorOffset;
            const focusOffset = selection.focusOffset;

            // Determine Direction
            let direction = 'LTR'; // Default (Common)

            // Logic: Compare positions to determine if dragging backwards (R->L)
            if (anchorNode === focusNode) {
                if (anchorOffset > focusOffset) direction = 'RTL';
            } else {
                const position = anchorNode.compareDocumentPosition(focusNode);
                if (position & Node.DOCUMENT_POSITION_PRECEDING) direction = 'RTL';
            }

            // Identify touched elements
            const tokens = document.querySelectorAll('.word-token');
            const tokenById = {};
            tokens.forEach(t => { tokenById[t.dataset.id] = t; });
            let actionTaken = false;
            const touchedTokens = Array.from(tokens).filter(token => selection.containsNode(token, true));
            if (!touchedTokens.length) return;
            const touchedIds = new Set(touchedTokens.map(token => token.dataset.id));
            const processedGroups = new Set();

            touchedTokens.forEach(token => {
                const targetId = token.dataset.id;
                const targetData = caseClosedData.targets.find(t => t.id === targetId);
                if (!targetData) return;

                if (targetData.type === 'proper' && groupById[targetId]) {
                    const groupId = groupById[targetId];
                    if (processedGroups.has(groupId)) return;
                    processedGroups.add(groupId);

                    const groupIds = multiWordGroups[groupId];
                    const groupTouched = groupIds.filter(id => touchedIds.has(id));
                    if (!groupTouched.length) return;

                    if (direction !== 'RTL') {
                        groupTouched.forEach(id => {
                            const el = tokenById[id];
                            if (el) triggerError(el, "Needs Capitalization! Drag R←L");
                        });
                        actionTaken = true;
                        return;
                    }

                    if (groupTouched.length === groupIds.length) {
                        completeGroup(groupId, groupIds);
                    } else {
                        partialGroup(groupId, groupTouched, groupIds);
                    }
                    actionTaken = true;
                    return;
                }

                if (solvedIds.has(targetId)) return;
                applyLogic(token, targetData, direction);
                actionTaken = true;
            });

            // Clear selection immediately to reset for next interaction
            if (actionTaken) {
                selection.removeAllRanges();
            }
        }

        function completeGroup(groupId, groupIds) {
            if (groupSolved.has(groupId)) return;
            groupIds.forEach(id => {
                const data = caseClosedData.targets.find(t => t.id === id);
                if (!data) return;
                const el = document.querySelector(`.word-token[data-id="${id}"]`);
                if (el && !solvedIds.has(id)) {
                    markCorrect(el, data, 'proper', 0);
                } else if (el) {
                    const duplicates = document.querySelectorAll(`.word-token[data-id="${id}"]`);
                    duplicates.forEach(node => {
                        node.classList.add('status-proper');
                        node.textContent = data.corrected;
                    });
                }
            });

            const currentScore = groupScores[groupId] || 0;
            const delta = 1 - currentScore;
            if (delta > 0) {
                solvedCount += delta;
                updateScore();
            }
            groupScores[groupId] = 1;
            groupSolved.add(groupId);
            showToast("Proper noun fixed!", 'text-cyan-400');
            saveState();

            if (solvedCount >= totalTargets) {
                setTimeout(() => {
                    const modal = document.getElementById('victory-modal');
                    modal.classList.remove('opacity-0', 'pointer-events-none');
                    modal.querySelector('div').classList.remove('scale-90');
                    if (window.parent && window.parent.MapSystem) {
                        window.parent.MapSystem.completeNode('DetectiveBoss');
                    }
                }, 1000);
            }
        }

        function partialGroup(groupId, touchedIds, groupIds) {
            groupPartialAttempts[groupId] = (groupPartialAttempts[groupId] || 0) + 1;
            touchedIds.forEach(id => {
                const data = caseClosedData.targets.find(t => t.id === id);
                if (!data) return;
                const el = document.querySelector(`.word-token[data-id="${id}"]`);
                if (el && !solvedIds.has(id)) {
                    markCorrect(el, data, 'proper', 0);
                }
            });

            const currentScore = groupScores[groupId] || 0;
            if (currentScore < 0.5) {
                solvedCount += 0.5;
                groupScores[groupId] = 0.5;
                updateScore();
            }

            showToast("Is that all?", 'text-cyan-400');
            if (groupPartialAttempts[groupId] >= 2) {
                showProperNounPointer();
            }
            saveState();
        }

        function applyLogic(element, data, direction) {
            const isProperAttempt = (direction === 'RTL'); // R->L
            const isCommonAttempt = (direction === 'LTR'); // L->R

            // LOGIC CHECK
            if (data.type === 'proper') {
                if (isProperAttempt) {
                    // CORRECT PROPER
                    markCorrect(element, data, 'proper');
                } else {
                    // WRONG (Tried to mark proper as common)
                    triggerError(element, "Needs Capitalization! Drag R←L");
                }
            } else if (data.type === 'common') {
                if (isCommonAttempt) {
                    // CORRECT COMMON
                    markCorrect(element, data, 'common');
                } else {
                    // WRONG (Tried to capitalize common)
                    triggerError(element, "It's just a Common Noun! Drag L→R");
                }
            }
        }

        function markCorrect(element, data, type, scoreDelta = 1) {
            solvedIds.add(data.id);
            if (scoreDelta > 0) {
                solvedCount += scoreDelta;
                updateScore();
            }

            // If there are other tokens with same ID (duplicates), update them too
            const duplicates = document.querySelectorAll(`.word-token[data-id="${data.id}"]`);
            duplicates.forEach(el => {
                if (type === 'proper') {
                    el.classList.add('status-proper');
                    el.textContent = data.corrected;
                } else {
                    el.classList.add('status-common');
                }
            });

            if (type === 'proper') {
                showToast(`Fixed: ${data.corrected}`, 'text-cyan-400');
            } else {
                showToast(`Identified: ${data.word}`, 'text-green-400');
            }

            console.log("Audio: Ding");
            saveState();

            // Check Win
            if (scoreDelta > 0 && solvedCount >= totalTargets) {
                setTimeout(() => {
                    const modal = document.getElementById('victory-modal');
                    modal.classList.remove('opacity-0', 'pointer-events-none');
                    modal.querySelector('div').classList.remove('scale-90');
                    // BRIDGE TO MAP SYSTEM
                    if (window.parent && window.parent.MapSystem) {
                        window.parent.MapSystem.completeNode('DetectiveBoss');
                    }
                }, 1000);
            }
        }

        function triggerError(element, msg) {
            element.classList.add('status-error');
            showToast(msg, 'text-red-400');
            setTimeout(() => {
                element.classList.remove('status-error');
            }, 500);
            console.log("Audio: Buzz");
            errors += 1;
            saveState();
        }

        function updateScore() {
            const displayValue = Number.isInteger(solvedCount) ? solvedCount : solvedCount.toFixed(1);
            document.getElementById('score-display').textContent = displayValue;
            const counterVal = document.getElementById('counter-val');
            if (counterVal) {
                counterVal.innerText = displayValue;
            }
        }

        function showProperNounPointer() {
            let pointer = document.getElementById('proper-noun-pointer');
            if (!pointer) {
                pointer = document.createElement('div');
                pointer.id = 'proper-noun-pointer';
                pointer.style.cssText = `
                    position: absolute;
                    right: 32px;
                    bottom: 32px;
                    z-index: 60;
                    background: rgba(8, 145, 178, 0.15);
                    border: 1px solid rgba(34, 211, 238, 0.6);
                    color: #e2e8f0;
                    padding: 14px 16px;
                    border-radius: 14px;
                    max-width: 260px;
                    font-size: 0.9rem;
                    box-shadow: 0 20px 40px rgba(0,0,0,0.35);
                    opacity: 0;
                    transition: opacity 0.3s ease;
                `;
                pointer.innerHTML = `
                    <div style="font-weight:700;color:#22d3ee;margin-bottom:6px;">Proper Noun Tip</div>
                    Multi‑word names are one proper noun. You must select both words together.
                `;
                document.getElementById('viewport-frame').appendChild(pointer);
            }
            pointer.style.opacity = '1';
            setTimeout(() => { pointer.style.opacity = '0'; }, 3500);
        }

        function showToast(msg, colorClass) {
            const toast = document.getElementById('feedback-toast');
            toast.textContent = msg;
            toast.className = `absolute top-4 right-8 bg-black/90 px-4 py-2 rounded-lg text-sm font-bold border border-white/10 transition-opacity duration-300 ${colorClass} z-20`;
            toast.style.opacity = '1';

            setTimeout(() => {
                toast.style.opacity = '0';
            }, 2000);
        }

        // Run
        lucide.createIcons();
        initEditor();

        // --- PREMIUM ENHANCEMENTS ---
        window.addEventListener('load', () => {
            gsap.to("#viewport-frame", {
                opacity: 1,
                duration: 1.2,
                ease: "power2.out"
            });

            document.addEventListener('mousemove', (e) => {
                const xPos = (e.clientX / window.innerWidth - 0.5) * 10;
                const yPos = (e.clientY / window.innerHeight - 0.5) * 10;
                gsap.to(".parallax-layer", {
                    x: xPos,
                    y: yPos,
                    duration: 2,
                    ease: "power2.out"
                });
            });
        });
    </script>
</body>

</html>
